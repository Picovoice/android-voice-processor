/*
    Copyright 2023 Picovoice Inc.

    You may not use this file except in compliance with the license. A copy of the license is
    located in the "LICENSE" file accompanying this source.

    Unless required by applicable law or agreed to in writing, software distributed under the
    License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
    express or implied. See the License for the specific language governing permissions and
    limitations under the License.
*/

package ai.picovoice.android.voiceprocessor;

import android.annotation.SuppressLint;
import android.media.AudioFormat;
import android.media.AudioRecord;
import android.media.MediaRecorder;
import android.os.Handler;
import android.os.Looper;
import android.os.Process;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * The Android Voice Processor is an asynchronous audio recorder designed for real-time
 * audio processing. Given some specifications, the library delivers frames of raw audio
 * data to the user via listeners. Audio will be 16-bit and mono.
 */
public class VoiceProcessor {

    private static VoiceProcessor instance = null;

    private final ArrayList<VoiceProcessorBufferListener> bufferListeners = new ArrayList<>();
    private final ArrayList<VoiceProcessorErrorListener> errorListeners = new ArrayList<>();
    private final AtomicBoolean isStopRequested = new AtomicBoolean(false);
    private final Handler callbackHandler = new Handler(Looper.getMainLooper());
    private final Object listenerLock = new Object();

    private Future<Void> readThread = null;
    private int frameLength;
    private int sampleRate;

    private VoiceProcessor(int frameLength, int sampleRate) {
        this.frameLength = frameLength;
        this.sampleRate = sampleRate;
    }

    /**
     * Obtain singleton instance of the VoiceProcessor.
     *
     * @param frameLength Number of audio samples per frame.
     * @param sampleRate  Audio sample rate that the audio will be captured with.
     * @return VoiceProcessor instance
     */
    public static synchronized VoiceProcessor getInstance(
            int frameLength,
            int sampleRate) {
        if (instance == null) {
            instance = new VoiceProcessor(frameLength, sampleRate);
        } else {
            instance.frameLength = frameLength;
            instance.sampleRate = sampleRate;
        }

        return instance;
    }

    /**
     * Indicates whether the VoiceProcessor is currently recording or not.
     *
     * @return boolean indicating whether the VoiceProcessor is currently recording.
     */
    public boolean getIsRecording() {
        return readThread != null;
    }

    /**
     * Add a buffer listener that will receive audio frames generated by the VoiceProcessor.
     *
     * @param listener VoiceProcessorBufferListener for processing frames of audio.
     */
    public void addBufferListener(VoiceProcessorBufferListener listener) {
        synchronized (listenerLock) {
            bufferListeners.add(listener);
        }
    }

    /**
     * Add multiple buffer listeners that will receive audio frames generated by the VoiceProcessor.
     *
     * @param listeners VoiceProcessorBufferListeners for processing frames of audio.
     */
    public void addBufferListeners(VoiceProcessorBufferListener[] listeners) {
        synchronized (listenerLock) {
            bufferListeners.addAll(Arrays.asList(listeners));
        }
    }

    /**
     * Remove a buffer listener from the VoiceProcessor. It will no longer receive audio frames.
     *
     * @param listener VoiceProcessorBufferListener that you would like to remove.
     */
    public void removeBufferListener(VoiceProcessorBufferListener listener) {
        synchronized (listenerLock) {
            bufferListeners.remove(listener);
        }
    }

    /**
     * Remove buffer listeners from the VoiceProcessor. They will no longer receive audio frames.
     *
     * @param listeners VoiceProcessorBufferListeners that you would like to remove.
     */
    public void removeBufferListeners(VoiceProcessorBufferListener[] listeners) {
        synchronized (listenerLock) {
            bufferListeners.removeAll(Arrays.asList(listeners));
        }
    }

    /**
     * Clear all buffer listeners from the VoiceProcessor. They will no longer receive audio frames.
     */
    public void clearBufferListeners() {
        synchronized (listenerLock) {
            bufferListeners.clear();
        }
    }

    /**
     * Get number of buffer listeners that are currently subscribed to the VoiceProcessor.
     *
     * @return the number of buffer listeners
     */
    public int getNumBufferListeners() {
        return bufferListeners.size();
    }

    /**
     * Add an error listener that will receive errors generated by the VoiceProcessor.
     *
     * @param errorListener VoiceProcessorErrorListener for catching recording errors.
     */
    public void addErrorListener(VoiceProcessorErrorListener errorListener) {
        synchronized (listenerLock) {
            errorListeners.add(errorListener);
        }
    }

    /**
     * Remove an error listener from the VoiceProcessor that had previously been added.
     *
     * @param errorListener VoiceProcessorErrorListener for catching recording errors.
     */
    public void removeErrorListener(VoiceProcessorErrorListener errorListener) {
        synchronized (listenerLock) {
            errorListeners.remove(errorListener);
        }
    }

    /**
     * Clear all error listeners from the VoiceProcessor.
     */
    public void clearErrorListeners() {
        synchronized (listenerLock) {
            errorListeners.clear();
        }
    }

    /**
     * Get number of error listeners that are currently subscribed to the VoiceProcessor.
     *
     * @return the number of error listeners
     */
    public int getNumErrorListeners() {
        return errorListeners.size();
    }

    /**
     * Starts audio capture. You need to subscribe a VoiceProcessorBufferListener via
     * {@link #addBufferListener(VoiceProcessorBufferListener)} in order to receive audio
     * frames from the VoiceProcessor.
     */
    public synchronized void start() {
        if (getIsRecording()) {
            return;
        }

        readThread = Executors.newSingleThreadExecutor().submit(new Callable<Void>() {
            @Override
            public Void call() {
                android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_AUDIO);
                read();
                return null;
            }
        });
    }

    /**
     * Stops audio capture. Frames will stop being delivered to the subscribed listeners.
     *
     * @throws VoiceProcessorException if an error is encountered while trying to stop the
     *                                 recorder thread.
     */
    public synchronized void stop() throws VoiceProcessorException {
        if (!getIsRecording()) {
            return;
        }

        isStopRequested.set(true);
        try {
            readThread.get();
            readThread = null;
        } catch (ExecutionException | InterruptedException e) {
            throw new VoiceProcessorException(
                    "An error was encountered while requesting to stop the audio recording",
                    e);
        } finally {
            isStopRequested.set(false);
        }
    }

    @SuppressLint("MissingPermission")
    private void read() {
        final int minBufferSize = AudioRecord.getMinBufferSize(
                this.sampleRate,
                AudioFormat.CHANNEL_IN_MONO,
                AudioFormat.ENCODING_PCM_16BIT);
        final int bufferSize = Math.max(this.sampleRate / 2, minBufferSize);

        AudioRecord recorder;
        try {
            recorder = new AudioRecord(
                    MediaRecorder.AudioSource.MIC,
                    this.sampleRate,
                    AudioFormat.CHANNEL_IN_MONO,
                    AudioFormat.ENCODING_PCM_16BIT,
                    bufferSize);
        } catch (IllegalArgumentException e) {
            onError(new VoiceProcessorException(
                    "Unable to initialize audio recorder with required parameters",
                    e));
            return;
        }

        if (recorder.getState() != AudioRecord.STATE_INITIALIZED) {
            onError(new VoiceProcessorException(
                    "Audio recorder did not initialize successfully. " +
                            "Ensure you have acquired permission to record audio from the user."));
            return;
        }

        final short[] buffer = new short[this.frameLength];
        try {
            recorder.startRecording();

            while (!isStopRequested.get()) {
                if (recorder.read(buffer, 0, buffer.length) == buffer.length) {
                    onBuffer(buffer);
                }
            }

            recorder.stop();
        } catch (IllegalStateException e) {
            onError(new VoiceProcessorException(
                    "Audio recorder entered invalid state",
                    e));
        } finally {
            recorder.release();
        }
    }

    private void onBuffer(final short[] buffer) {
        synchronized (listenerLock) {
            for (final VoiceProcessorBufferListener listener : bufferListeners) {
                callbackHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        listener.onBuffer(buffer);
                    }
                });
            }
        }
    }

    private void onError(final VoiceProcessorException e) {
        synchronized (listenerLock) {
            for (final VoiceProcessorErrorListener listener : errorListeners) {
                callbackHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        listener.onError(e);
                    }
                });
            }
        }
    }
}